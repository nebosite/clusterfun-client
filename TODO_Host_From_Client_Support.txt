TODO - Host From Client Support:

This document lists an implementation plan for separating the concept of a game host
from a presenter, in order to allow for games where a mobile client device hosts the game
instead of an independent presenter device. This allows ClusterFun to be played in scenarios
where a presenter device is not available (such as if everyone is sitting around a dinner table).
Closely related to this is the idea of running the host in a WebWorker, so that any complex
calculations to be done by the game (such as calculating Lexible's word bank) do not block the UI
thread, and the idea of a VIP client, allowing the game to be entirely controlled
from client devices once a device begins hosting a game.

VIP CLIENT:

Priority: High (necessary for host from client)

This feature designates a VIP in each game that is responsible for starting games and changing
settings. This allows 1) the game to be controlled from a client phone without touching the presenter,
and 2) the game to be controlled from a client host.

[ ] Add a "vip" property for players
    [ ] Assign this property from the relay server to the first presenter or client device that joins a room
        [ ] At this stage, this should always be the host device, since the UI thread
            of that device will immediately join the game before showing the room code
    [ ] When a device joins a room, inform them if they have VIP status
    [ ] Add a setting, defaulting to ON, in the presenter main menu, which causes the server
        to wait to assign VIP until the first client joins
        [ ] This reflects the default behavior of the VIP setting in Jackbox, which is
            assigned to the first actual player who joins the game
        [ ] PERHAPS: Consider a security setting that only assigns VIP to a specific player
            or first in a set of players
    [ ] If the VIP player leaves a lobby, reassign it to the next available player
        [ ] It might be permissible to make players leave and come back to get the VIP client title
[ ] The player with the VIP property, be it client or presenter, is the one with the
    UI controls to start a game and change settings
    [ ] Add appropriate infrastructure in the base communications to inform the host
        of who the VIP is. (Note that it needs trust from the server to do this)
    [ ] Grant easy access to the VIP's personal ID in the host game model, in order to
        send privleged messages
    [ ] Allow the VIP to quit the game (clicking the Quit button that every game has)
[ ] (NOTE: the VIP dynamic has no effect on Stressato other than the Quit button, since
    the presenter has no controls)
[ ] Implement the VIP client affordances for Testato
    [ ] Allow starting the game from the lobby screen
[ ] Implement the VIP client affordances for Lexible
    [ ] Allow starting the game from the lobby screen
    [ ] Allow changing the settings from the lobby screen
        [ ] Request the current settings from the host/presenter
            in order to provide the initial state of the buttons
    [ ] Allow operating the instructions slideshow

WEB WORKER HOST:

Priority: High (necessary for host from client)

This code moves the hosting duties for a game to a separate "host" role
that runs on a background thread. This both reduces load on the UI thread
and is a prerequisite for running the host on a client device.

[ ] Allow SessionHelper to store a separate MessageThing for each participant.
    [ ] Start with a default message thing, much as we have now
    [ ] Allow adding a message thing for a specific recipient, which will be used
        instead of the default MessageThing.
        [ ] Ensure that the new MessageThing has the same personal ID and secret
        [ ] PERHAPS: Hide the personal secret from SessionHelper
            [ ] Rework ClusterfunPresenterModel's action of terminating the game
                so that it doesn't have to view the presenter secret. We might do
                this by reworking serverCall() into a proper interface.
    [ ] Note: Sending a message to MessageThing still requires including the recipient.
        This allows the same MessageThing to be used for multiple endpoints.
[ ] Add an IMessageThing based on the MessagePort object (used by Web Workers).
    [ ] Sending a message to, or receiving a message from, this MessageThing
        should use the provided MessagePort.
    [ ] Connect other events as well, such as closed ports for terminated WebWorkers.
    [ ] Rename LocalMessageThing as needed - this should explicitly indicate that it
        stays in the same thread.
[ ] Create a headless Presenter for Stressato
    [ ] Create a (dedicated) WebWorker module that:
        [ ] Connects to the Stressato game room
        [ ] Initializes a Stressato Presenter model
        [ ] Creates a separate MessagePort for receiving messages, passing it along
            when the port is initialized
    [ ] Initialize this worker, getting its created port. The main "postMessage" is used to
        issue commands, and the port is used to send messages.
    [ ] Ensure that the host restores and keeps its state across refreshes
    [ ] Create a dummy component to host this host worker, only providing a button to close it.
        (You could factor in the VIP system here)
[ ] Change Presenter to Host throughout the model sections of the codebase
    [ ] Change the "presenter" role to the "host" role
    [ ] Change all APIs mentioning "presenter" to mention "host" instead - in general,
        any messages that would have been sent by clients to the "presenter" will go to the
        host instead
    [ ] NOTE: Leave the Presenter UI components alone - we will fix those later
[ ] Reintroduce Presenter as a separate concept
    [ ] Recreate the "presenter" role, with none of the original meaning it carried on the server
    [ ] Create a separate presenter model that _only_ presents the game - it does not run
        game logic
    [ ] Attach the Presenter UI to this new model
    [ ] On initialization, a presenter will do a full state resync with the host.
    [ ] Afterwards, the host pushes updates to the presenter
    [ ] FOR NOW: Only allow one presenter - the relay server should reject any more
[ ] When hosting a new game of Stressato from a presenter device, create a background host
    and foreground Presenter
    [ ] The presenter model is attached to Stressato's presenter UI
    [ ] The host is in a background thread
    [ ] Every time the host updates its statistics, it sends them to the presenter
[ ] Implement the host/presenter distinction changes for Testato
    [ ] Broadcast the player list from the host to the VIP client
    [ ] Get an initial presenter state on startup
    [ ] Stream changes to player words/colors/positions
[ ] Implement the host/presenter distinction changes for Lexible
    [ ] Broadcast the player list to the VIP client
    [ ] Get an initial presenter state on startup, including full game and menu state
    [ ] Be sure that the host uses its own LocalStorage for settings, and broadcast
        those to the presenter
        [ ] If we allow changing settings from the presenter, broadcast those changes
            back to the host
    [ ] Broadcast board updates to the presenter, much as we already do for clients
    [ ] Broadcast game state changes to the presenter, such as winning a round or match,
        much as we already do for clients

HOST FROM CLIENT:

Priority: High (allows playing Lexible without an extra presenter device, making it easier
to demo)

This feature allows for hosting a game from a client device without a presenter at all.
For instance, this allows Lexible to be played around a dinner or restaurant table
where an extra device is either difficult or impossible to secure.

[ ] Where possible, always display the room code on client devices. (This allows the
    room code to remain visible even if no presenter exists)
[ ] For testing, put a button on the main client screen that starts a game of Stressato with a headless
    Presenter.
    [ ] Create the worker, getting its created port to create a MessageThing for it
    [ ] Use the native postMessage() API to send commands, the port to send messages
    [ ] Start a client UI/model, using this connection to send messages to the presenter
[ ] Do the same tests for Testato
    [ ] Verify that the VIP is properly assigned and the hosting device can start the game
[ ] Do the same tests for Lexible
    [ ] Verify that the VIP is properly assigned
[ ] Modify the client's UI to officially support hosting from client
    [ ] Add a portrait version of the game list for hosting a game from client
        [ ] Accessible through the "I want to host a game" button - add a separate
            button to go to the landscape "presenter" page
        [ ] Each game button hosts that game and starts a client/host pair    
[ ] IF NEEDED: If we have a game where the presenter _must_ exist, disable these games
    on the client hosting page.
    [ ] Add an explanatory help text

SEPARATE PRESENTER:

Priority: Low (could be useful for Lexible or Stressato)

Once we allow hosting a game from client, this feature allows creating one or more presenters
after the fact. This feature takes advantage of the fact that a message channel is already used
to connect the host and presenter - if that channel is changed to a Web Socket, it should still work
as long as not too much data is sent.

[ ] Change the presenter main menu to allow connecting to an existing game
    [ ] Add a room code field and "Present" button to the left of the game list
    [ ] Label both sections accordingly ("host a game" and "present an existing game")
[ ] When an existing game is joined from the presenter main menu, start a Presenter UI
    that connects to that game
    [ ] Have the host recognize the new presenter, get it up to speed, and stream updates as before
[ ] IF NEEDED: If we have a game that sends too much data from host to presenter for the
    Web Socket connection to work well, cause the after-the-fact presenter join to fail with an
    appropriate error message.
[ ] PERHAPS, IF NEEDED: If we have a game where a presenter must exist, but where not too much data is sent
    from host to presenter, allow hosting the game from the client, but do not allow the game to start
    until a presenter is connected.

NON-PRESENTER AFFORDANCES:

Priority: Low (could be useful for Lexible's minimap)

This is for games where important data is displayed on the presenter, but where it can
appear on the client if there isn't one.

[ ] Tell the host and clients when no Presenter is running
    [ ] NOTE: This might not be important if we allow multiple Presenters to exist at once,
        since players can create tabbed Presenters to view Presenter-specific information.
        We might also specifically discourage non-Presenter play by removing associated
        affordances.
    [ ] NOTE: If we do care about this distinction, it might be better to implement it as
        UI settings on each client, so that players are not locked out of Presenter-relevant
        information if they don't have a Presenter in front of them
    [ ] Implement this for Lexible 
        [ ] Allow a minimap on client devices when a Presenter can't show the full map

TRANSFER LIST:

Priority: Very Low (none of our games need this yet)

This is for games that send lots of data from host to presenter (e.g. graphics- and audio-
intensive games) and need to run them on the same computer. The transfer list feature
of Web Worker messages allows these messages to be sent without copying, thus reducing
the load on the device.

[ ] Add a transfer list to requests and responses - alongside the actual message object,
    store a list of members that should be moved instead of copied.
    [ ] In the MessagePort-based MessageThing, use the transfer list when sending
        the message.
    [ ] In the WebSocket-based MessageThing, do not use the transfer list,
        instead throwing an error if a non-JSON-serializable object is encountered.
        (note: see below item about cloning certain objects)
    [ ] In LocalMessageThing, add modes to simulate either of the above
        [ ] In "WebSocket compatibility mode", do not use the transfer list
        [ ] In "MessagePort compatibility mode", use the transfer list and call
            structuredClone() to duplicate the message.
[ ] Allow the host to tell when the transfer list feature is available (i.e. it is
    when the presenter is connected over a Web Worker, and is not when the presenter
    is available over a web socket).
[ ] If there is a game that needs the transfer list, and cannot adequately compress
    the information over a non-transfer-list channel, ensure that it is marked as
    requiring a presenter and not being able to start a presenter after the fact.

TRULY HEADLESS HOST:

Priority: Very Low (none of our games need this yet)

This feature allows the host code to be run on a headless device. This would be used
to either run a host over SSH, or run host code on the Clusterfun server itself to
avoid deploying it.

[ ] Allow a truly headless host
    [ ] Publish a CLI executable that creates a truly headless
        Clusterfun host (for running over SSH or on the server)
        [ ] The executable starts a host worker and prints its room code.
        [ ] CTRL+C or appropriate termination signals end the game
        [ ] Package with Node or Deno
[ ] PERHAPS: Add a mode on the presenter homepage that enables a low-power mode
    [ ] Add a checkbox on the presenter homepage for this
    [ ] When enabled, instead of creating a presenter role and UI, just show
        a page that offers control buttons and plays an animation to assure you
        that the host is working (perhaps it joins as a separate role and pings
        the host to do this)

